# Agent Executor Platform Manifests

This directory contains Kubernetes manifests for deploying the agent-executor service using GitOps and Crossplane.

## Architecture

The agent-executor service follows the **"Database per Service"** pattern with **Zero-Touch** provisioning:

### Database Provisioning (Crossplane)
- **PostgreSQL**: Provisioned via `postgres-claim.yaml` → Secret: `agent-executor-db-conn`
- **Dragonfly**: Provisioned via `dragonfly-claim.yaml` → Secret: `agent-executor-cache-conn`
- **Secrets**: Auto-generated by Crossplane (no SSM, no ExternalSecrets)

### Secret Management
- **LLM API Keys**: Managed via External Secrets Operator (ESO) from AWS SSM
- **GitHub Registry**: Managed via ESO from AWS SSM
- **Database Credentials**: Auto-generated by Crossplane (NOT in SSM)

## Files

### Database Claims
- `postgres-claim.yaml` - PostgreSQL database claim → creates `agent-executor-db-conn` secret
- `dragonfly-claim.yaml` - Dragonfly cache claim → creates `agent-executor-cache-conn` secret

### Kubernetes Resources
- `namespace.yaml` - Namespace definition
- `nats-stream.yaml` - NATS JetStream configuration
- `agent-executor-deployment.yaml` - Deployment, Service, and KEDA ScaledObject

### External Secrets (ESO)
- `external-secrets/llm-keys-es.yaml` - LLM API keys from AWS SSM
- `external-secrets/image-pull-secret-es.yaml` - GitHub registry credentials from AWS SSM

## Deployment Flow

```
1. Crossplane Claims (sync-wave: 0)
   ├── PostgreSQL instance provisioned
   ├── Dragonfly instance provisioned
   └── Connection secrets auto-created:
       ├── agent-executor-db-conn
       └── agent-executor-cache-conn

2. NATS Stream (sync-wave: 1)
   └── JetStream stream and consumer created

3. Deployment (sync-wave: 2)
   ├── Init container runs migrations
   └── Main container starts with NATS consumer
```

## Connection Details

### PostgreSQL (Zero-Touch)
- **Claim**: `agent-executor-db`
- **Secret**: `agent-executor-db-conn` (auto-created)
- **Keys**: `endpoint`, `port`, `username`, `password`, `database`
- **Endpoint**: `agent-executor-db-rw.intelligence-deepagents.svc.cluster.local:5432`

### Dragonfly (Zero-Touch)
- **Claim**: `agent-executor-cache`
- **Secret**: `agent-executor-cache-conn` (auto-created)
- **Keys**: `endpoint`, `port`, `password`
- **Endpoint**: `agent-executor-cache.intelligence-deepagents.svc.cluster.local:6379`

### NATS
- **Endpoint**: `nats://nats.nats.svc:4222`
- **Stream**: `AGENT_EXECUTION`
- **Consumer**: `agent-executor-workers`

## Zero-Touch Pattern

Both databases follow the same convention:

| Database | Claim Name | Connection Secret |
|----------|------------|-------------------|
| PostgreSQL | `agent-executor-db` | `agent-executor-db-conn` |
| Dragonfly | `agent-executor-cache` | `agent-executor-cache-conn` |

**Rule**: Secret name = `{claim-name}-conn`

No `connectionSecretName` needed in claims - it's auto-derived!

## Benefits of This Architecture

1. **Zero-Touch**: Commit YAML, platform provisions infrastructure
2. **Security**: No credentials in Git or SSM for databases
3. **Isolation**: Dedicated database instances per service
4. **Scalability**: KEDA autoscaling based on NATS queue depth
5. **GitOps**: All changes via Git commits, ArgoCD syncs automatically
6. **Convention over Configuration**: Predictable secret names

## Updating

### To update the service image:
```bash
# Edit agent-executor-deployment.yaml
# Change image tag
git commit -m "chore: Update agent-executor to v1.0.1"
git push
# ArgoCD syncs automatically
```

### To scale database resources:
```bash
# Edit postgres-claim.yaml or dragonfly-claim.yaml
# Change size: small/medium/large or storageGB
git commit -m "feat: Scale postgres to large"
git push
# Crossplane updates resources
```

### To rotate LLM API keys:
```bash
# Update AWS SSM parameter
aws ssm put-parameter --name /zerotouch/prod/agent-executor/openai_api_key --value "sk-new-key" --type SecureString --overwrite
# ESO syncs automatically within 1 hour (or force sync)
```
