name: In-Cluster Integration Tests

# ==============================================================================
# Reusable Workflow for In-Cluster Testing
# ==============================================================================
# This workflow can be called by other workflows to run integration tests
# in a Kubernetes cluster environment.
#
# Usage in other workflows:
#   jobs:
#     integration-tests:
#       uses: ./.github/workflows/in-cluster-test.yml
#       with:
#         test-path: "tests/integration/test_nats_events_integration.py"
#         test-name: "nats-events"
#         timeout: 600
# ==============================================================================

on:
  workflow_call:
    inputs:
      test-path:
        description: 'Path to test files (e.g., tests/integration/test_nats_events_integration.py)'
        required: true
        type: string
      test-name:
        description: 'Name for the test suite (used in job names and artifacts)'
        required: true
        type: string
      timeout:
        description: 'Timeout in seconds for test execution'
        required: false
        type: number
        default: 600
      image-tag:
        description: 'Docker image tag to use for testing'
        required: false
        type: string
        default: 'ci-test'
      namespace:
        description: 'Kubernetes namespace to use'
        required: false
        type: string
        default: 'intelligence-deepagents'
      use-real-llm:
        description: 'Whether to use real LLM APIs (requires secrets)'
        required: false
        type: boolean
        default: false
    secrets:
      OPENAI_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false
      BOT_GITHUB_TOKEN:
        required: false
      BOT_GITHUB_USERNAME:
        required: false
      AWS_ROLE_ARN:
        required: false

permissions:
  id-token: write      # Required for AWS OIDC authentication
  contents: read
  pull-requests: write

jobs:
  in-cluster-tests:
    name: ${{ inputs.test-name }} Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.BOT_GITHUB_TOKEN || github.token }}
      
      - name: Checkout zerotouch-platform
        uses: actions/checkout@v4
        with:
          repository: 'arun4infra/zerotouch-platform'
          path: 'zerotouch-platform'
          token: ${{ secrets.BOT_GITHUB_TOKEN || github.token }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-south-1
          mask-aws-account-id: true
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build test image
        run: |
          docker build -t deepagents-runtime:${{ inputs.image-tag }} .
      
      - name: Create Kind configuration
        run: |
          # Install kind if not available
          if ! command -v kind &> /dev/null; then
            echo "Installing kind..."
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
            chmod +x ./kind
            sudo mv ./kind /usr/local/bin/kind
          fi
          
          # Create Kind config that mounts zerotouch-platform subdirectory to /repo
          mkdir -p /tmp/kind
          cat > /tmp/kind/config.yaml << EOF
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          name: zerotouch-preview
          nodes:
          - role: control-plane
            extraPortMappings:
            # NATS client port
            - containerPort: 30080
              hostPort: 4222
              protocol: TCP
            # PostgreSQL port
            - containerPort: 30432
              hostPort: 5432
              protocol: TCP
            # Dragonfly (Redis-compatible) port
            - containerPort: 30379
              hostPort: 6379
              protocol: TCP
            extraMounts:
            # Mount zerotouch-platform subdirectory for ArgoCD to sync from
            - hostPath: $(pwd)/zerotouch-platform
              containerPath: /repo
              readOnly: true
          EOF
      
      - name: Set up Kind cluster
        run: |
          kind create cluster --config /tmp/kind/config.yaml
          # Set kubectl context and label nodes
          kubectl config use-context kind-zerotouch-preview
          kubectl label nodes --all workload.bizmatters.dev/databases=true --overwrite
      
      - name: Load Docker image into Kind
        run: |
          kind load docker-image deepagents-runtime:${{ inputs.image-tag }} --name zerotouch-preview
      
      - name: Bootstrap platform
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          BOT_GITHUB_USERNAME: ${{ secrets.BOT_GITHUB_USERNAME }}
          BOT_GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          TENANTS_REPO_NAME: ${{ secrets.TENANTS_REPO_NAME }}
        run: |
          # Bootstrap the platform using the existing zerotouch-platform
          cd zerotouch-platform
          chmod +x scripts/bootstrap/01-master-bootstrap.sh
          ./scripts/bootstrap/01-master-bootstrap.sh --mode preview
      
      - name: Apply preview patches
        run: |
          # Apply preview environment patches for resource optimization
          chmod +x scripts/patches/00-apply-all-patches.sh
          ./scripts/patches/00-apply-all-patches.sh --force
      
      - name: Run pre-deploy diagnostics
        run: |
          # Run pre-deployment diagnostics
          chmod +x scripts/ci/pre-deploy-diagnostics.sh
          ./scripts/ci/pre-deploy-diagnostics.sh
      
      - name: Deploy service
        env:
          IMAGE_TAG: ${{ inputs.image-tag }}
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Deploy the service using existing scripts
          ./scripts/ci/deploy.sh
      
      - name: Run post-deploy diagnostics
        env:
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Run post-deployment diagnostics
          chmod +x scripts/ci/post-deploy-diagnostics.sh
          ./scripts/ci/post-deploy-diagnostics.sh ${{ inputs.namespace }} deepagents-runtime
      
      - name: Run in-cluster tests
        env:
          TEST_PATH: ${{ inputs.test-path }}
          TEST_NAME: ${{ inputs.test-name }}
          TIMEOUT: ${{ inputs.timeout }}
          NAMESPACE: ${{ inputs.namespace }}
          USE_REAL_LLM: ${{ inputs.use-real-llm }}
          USE_MOCK_LLM: ${{ inputs.use-real-llm == false && 'true' || 'false' }}
          MOCK_TIMEOUT: "60"
          ZEROTOUCH_PLATFORM_DIR: "./zerotouch-platform"
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          # Database credentials from K8s secrets (will be available in pod)
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'langgraph_dev' }}
          DRAGONFLY_PASSWORD: ${{ secrets.DRAGONFLY_PASSWORD || 'dragonfly' }}
        run: |
          # Create and run test job using template
          export JOB_NAME="${{ inputs.test-name }}-$(date +%s)"
          
          # Substitute variables in template
          sed -e "s/{{JOB_NAME}}/$JOB_NAME/g" \
              -e "s/{{NAMESPACE}}/${{ inputs.namespace }}/g" \
              -e "s/{{IMAGE}}/deepagents-runtime:${{ inputs.image-tag }}/g" \
              -e "s|{{TEST_PATH}}|${{ inputs.test-path }}|g" \
              -e "s/{{TEST_NAME}}/${{ inputs.test-name }}/g" \
              scripts/ci/test-job-template.yaml > /tmp/test-job.yaml
          
          # Apply job and wait for completion
          kubectl apply -f /tmp/test-job.yaml
          kubectl wait --for=condition=complete --timeout=${{ inputs.timeout }}s job/$JOB_NAME -n ${{ inputs.namespace }}
          
          # Copy artifacts
          POD_NAME=$(kubectl get pods -n ${{ inputs.namespace }} -l job-name=$JOB_NAME -o jsonpath='{.items[0].metadata.name}')
          mkdir -p artifacts
          kubectl cp ${{ inputs.namespace }}/$POD_NAME:/app/artifacts/ ./artifacts/ || true
      
      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.test-name }}-test-artifacts
          path: |
            artifacts/
            scripts/local/ci/logs/
          retention-days: 30
      
      - name: Parse test results
        if: always() && github.event_name == 'pull_request'
        id: parse_results
        run: |
          if [ -f artifacts/test-results.xml ]; then
            TESTS=$(grep -oP 'tests="\K[0-9]+' artifacts/test-results.xml | head -1)
            FAILURES=$(grep -oP 'failures="\K[0-9]+' artifacts/test-results.xml | head -1)
            ERRORS=$(grep -oP 'errors="\K[0-9]+' artifacts/test-results.xml | head -1)
            
            echo "tests=${TESTS:-0}" >> $GITHUB_OUTPUT
            echo "failures=${FAILURES:-0}" >> $GITHUB_OUTPUT
            echo "errors=${ERRORS:-0}" >> $GITHUB_OUTPUT
          else
            echo "tests=0" >> $GITHUB_OUTPUT
            echo "failures=0" >> $GITHUB_OUTPUT
            echo "errors=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Comment PR with test results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const tests = '${{ steps.parse_results.outputs.tests }}';
            const failures = '${{ steps.parse_results.outputs.failures }}';
            const errors = '${{ steps.parse_results.outputs.errors }}';
            const passed = parseInt(tests) - parseInt(failures) - parseInt(errors);
            const success = parseInt(failures) === 0 && parseInt(errors) === 0;
            
            const emoji = success ? '‚úÖ' : '‚ùå';
            const status = success ? 'PASSED' : 'FAILED';
            const testName = '${{ inputs.test-name }}';
            
            const body = `## ${emoji} ${testName} Tests ${status}
            
            **Test Summary:**
            - Total Tests: ${tests}
            - Passed: ${passed}
            - Failed: ${failures}
            - Errors: ${errors}
            
            **Infrastructure:** In-Cluster Kubernetes (Kind + ArgoCD)
            **Test Path:** \`${{ inputs.test-path }}\`
            
            ${success ? 'üéâ All tests passed!' : '‚ö†Ô∏è Some tests failed. Please review the artifacts for details.'}
            
            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: Cleanup
        if: always()
        run: |
          # Get logs from failed pods for debugging
          if kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | grep -q .; then
            echo "=== Failed Pod Logs ==="
            kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | while read pod; do
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n ${{ inputs.namespace }} || true
            done
          fi
          
          # Clean up test jobs
          kubectl delete jobs -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --ignore-not-found=true
          
          # Clean up the Kind cluster
          kind delete cluster --name zerotouch-preview || true