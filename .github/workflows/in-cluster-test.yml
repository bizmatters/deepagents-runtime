name: In-Cluster Integration Tests

# ==============================================================================
# Reusable Workflow for In-Cluster Testing
# ==============================================================================
# This workflow can be called by other workflows to run integration tests
# in a Kubernetes cluster environment.
#
# Usage in other workflows:
#   jobs:
#     integration-tests:
#       uses: ./.github/workflows/in-cluster-test.yml
#       with:
#         test-path: "tests/integration/test_nats_events_integration.py"
#         test-name: "nats-events"
#         timeout: 600
# ==============================================================================

on:
  workflow_call:
    inputs:
      test-path:
        description: 'Path to test files (e.g., tests/integration/test_nats_events_integration.py)'
        required: true
        type: string
      test-name:
        description: 'Name for the test suite (used in job names and artifacts)'
        required: true
        type: string
      timeout:
        description: 'Timeout in seconds for test execution'
        required: false
        type: number
        default: 600
      image-tag:
        description: 'Docker image tag to use for testing'
        required: false
        type: string
        default: 'ci-test'
      namespace:
        description: 'Kubernetes namespace to use'
        required: false
        type: string
        default: 'intelligence-deepagents'
      use-real-llm:
        description: 'Whether to use real LLM APIs (requires secrets)'
        required: false
        type: boolean
        default: false
    secrets:
      OPENAI_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false
      BOT_GITHUB_TOKEN:
        required: false

permissions:
  contents: read
  pull-requests: write

jobs:
  in-cluster-tests:
    name: ${{ inputs.test-name }} Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.BOT_GITHUB_TOKEN || github.token }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build test image
        run: |
          docker build -t deepagents-runtime:${{ inputs.image-tag }} .
      
      - name: Set up Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: zerotouch-preview
      
      - name: Load Docker image into Kind
        run: |
          kind load docker-image deepagents-runtime:${{ inputs.image-tag }} --name zerotouch-preview
      
      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-application-controller -n argocd
      
      - name: Bootstrap platform
        run: |
          # Bootstrap the platform using the existing zerotouch-platform
          cd ../zerotouch-platform
          chmod +x scripts/bootstrap/01-master-bootstrap.sh
          ./scripts/bootstrap/01-master-bootstrap.sh --mode preview
      
      - name: Deploy service
        env:
          IMAGE_TAG: ${{ inputs.image-tag }}
          NAMESPACE: ${{ inputs.namespace }}
        run: |
          # Deploy the service using existing scripts
          ./scripts/ci/deploy.sh
      
      - name: Run in-cluster tests
        env:
          TEST_PATH: ${{ inputs.test-path }}
          TEST_NAME: ${{ inputs.test-name }}
          TIMEOUT: ${{ inputs.timeout }}
          NAMESPACE: ${{ inputs.namespace }}
          IMAGE: deepagents-runtime:${{ inputs.image-tag }}
          USE_REAL_LLM: ${{ inputs.use-real-llm }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Make the centralized test script executable
          chmod +x scripts/ci/in-cluster-test.sh
          
          # Set LLM mode based on input
          if [ "$USE_REAL_LLM" = "true" ]; then
            export USE_MOCK_LLM="false"
            export REAL_TIMEOUT="480"
            echo "Using real LLM APIs for testing"
          else
            export USE_MOCK_LLM="true"
            export MOCK_TIMEOUT="60"
            echo "Using mock LLM for testing"
          fi
          
          # Run the tests
          ./scripts/ci/in-cluster-test.sh "$TEST_PATH" "$TEST_NAME" "$TIMEOUT"
      
      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.test-name }}-test-artifacts
          path: |
            artifacts/
            scripts/local/ci/logs/
          retention-days: 30
      
      - name: Parse test results
        if: always() && github.event_name == 'pull_request'
        id: parse_results
        run: |
          if [ -f artifacts/test-results.xml ]; then
            TESTS=$(grep -oP 'tests="\K[0-9]+' artifacts/test-results.xml | head -1)
            FAILURES=$(grep -oP 'failures="\K[0-9]+' artifacts/test-results.xml | head -1)
            ERRORS=$(grep -oP 'errors="\K[0-9]+' artifacts/test-results.xml | head -1)
            
            echo "tests=${TESTS:-0}" >> $GITHUB_OUTPUT
            echo "failures=${FAILURES:-0}" >> $GITHUB_OUTPUT
            echo "errors=${ERRORS:-0}" >> $GITHUB_OUTPUT
          else
            echo "tests=0" >> $GITHUB_OUTPUT
            echo "failures=0" >> $GITHUB_OUTPUT
            echo "errors=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Comment PR with test results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const tests = '${{ steps.parse_results.outputs.tests }}';
            const failures = '${{ steps.parse_results.outputs.failures }}';
            const errors = '${{ steps.parse_results.outputs.errors }}';
            const passed = parseInt(tests) - parseInt(failures) - parseInt(errors);
            const success = parseInt(failures) === 0 && parseInt(errors) === 0;
            
            const emoji = success ? '‚úÖ' : '‚ùå';
            const status = success ? 'PASSED' : 'FAILED';
            const testName = '${{ inputs.test-name }}';
            
            const body = `## ${emoji} ${testName} Tests ${status}
            
            **Test Summary:**
            - Total Tests: ${tests}
            - Passed: ${passed}
            - Failed: ${failures}
            - Errors: ${errors}
            
            **Infrastructure:** In-Cluster Kubernetes (Kind + ArgoCD)
            **Test Path:** \`${{ inputs.test-path }}\`
            
            ${success ? 'üéâ All tests passed!' : '‚ö†Ô∏è Some tests failed. Please review the artifacts for details.'}
            
            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: Cleanup
        if: always()
        run: |
          # Get logs from failed pods for debugging
          if kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | grep -q .; then
            echo "=== Failed Pod Logs ==="
            kubectl get pods -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --field-selector=status.phase=Failed -o name | while read pod; do
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n ${{ inputs.namespace }} || true
            done
          fi
          
          # Clean up test jobs
          kubectl delete jobs -n ${{ inputs.namespace }} -l test-suite=${{ inputs.test-name }} --ignore-not-found=true
          
          # Clean up the Kind cluster
          kind delete cluster --name zerotouch-preview || true